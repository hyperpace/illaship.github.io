<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Alogrithm_003]괄호]]></title>
    <url>%2F2018%2F03%2F12%2Falgorithm%2F%5BAlogrithm_003%5D%EA%B4%84%ED%98%B8%2F</url>
    <content type="text"><![CDATA[문제 괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 입력 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다. 출력 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다. 출처 백준온라인저지-9012번-괄호(https://www.acmicpc.net/problem/9012) 풀이 방법 - 스택(Stack) 이용 스택의 마지막에 넣은것이 가장 먼저 나오는 구조를 이용한다. 입력받은 문자열의 길이 만큼 Loop를 돈다. 문자 (를 발견하면 스택(Stack)에 push() 문자 )를 발견하면 스택(Stack)에서 pop() 만약, Loop동안 스택의 길이가 0보다 작아지려 한다면 NO Loop가 끝난 뒤, 스택의 길이가 0이면 YES Loop가 끝난 뒤, 스택의 길이가 0보다 크면 NO1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;string isVps(string str) &#123; stack&lt;char&gt; st; for(int i = 0; i &lt; str.length(); i++) &#123; char c = str.at(i); if(c == '(') &#123; st.push(c); &#125; else if(c == ')') &#123; if(st.size() == 0) &#123; return "NO"; &#125; st.pop(); &#125; &#125; if(st.size() == 0) &#123; return "YES"; &#125; else &#123; return "NO"; &#125;&#125;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; string str; cin &gt;&gt; str; cout &lt;&lt; isVps(str) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>basics</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[DataStructure_003]덱(Deque)]]></title>
    <url>%2F2018%2F03%2F12%2Fdatastructure%2F%5BDataStructure_003%5D%EB%8D%B1(Deque)%2F</url>
    <content type="text"><![CDATA[덱 소개 양 끝에서 자료를 삽입과 삭제를 할 수 있는 자료구조입니다. 큐와 다르게 양 끝에서 삽입과 삭제가 가능하므로 Double-ended queue라고 부릅니다. 덱 연산 함수 설명 push_front 덱의 앞에 자료를 삽입하는 연산. push_back 덱의 뒤에 자료를 삽입하는 연산. pop_front 덱의 앞에서 자료를 삭제하는 연산. pop_back 덱의 뒤에서 자료를 삭제하는 연산. front 덱의 가장 앞에 있는 자료를 보는 연산. back 덱의 가장 뒤에 있는 자료를 보는 연산.]]></content>
      <categories>
        <category>basics</category>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[DataStructure_002]큐(Queue)]]></title>
    <url>%2F2018%2F03%2F12%2Fdatastructure%2F%5BDataStructure_002%5D%ED%81%90(Queue)%2F</url>
    <content type="text"><![CDATA[큐 소개 한쪽 끝에서만 자료를 삽입하고 반대 쪽 끝에서만 삭제할 수 있는 자료구조입니다. 먼저 넣은 것이 가장 먼저 나오기 때문에 First In First Out(FIFO)라고도 부릅니다. 큐 연산 함수 설명 push 큐에 자료를 삽입하는 연산. pop 큐에서 자료를 삭제하는 연산 front 큐의 가장 앞(가장 먼저 삽입)에 있는 자료를 보는 연산. back 큐에서 가장 뒤(가장 나중에 삽입)에 있는 자료를 보는 연산. empty 큐가 비어 있는지 아닌지 보는 연산. size 큐에 저장되어있는 자료의 개수를 보는 연산.]]></content>
      <categories>
        <category>basics</category>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[DataStructure_001]스택(Stack)]]></title>
    <url>%2F2018%2F03%2F12%2Fdatastructure%2F%5BDataStructure_001%5D%EC%8A%A4%ED%83%9D(Stack)%2F</url>
    <content type="text"><![CDATA[스택 소개 한쪽 끝에서만 자료를 삽입, 삭제할 수 있는 자료구조입니다. 마지막에 넣은것이 가장 먼저 나오기 때문에, Last in First Out(LIFO)라고도 부릅니다. 스택 연산 함수 설명 push 스택에 자료를 삽입하는 연산 pop 스택에서 자료를 삭제하는 연산 top 스택의 가장 위에 있는 자료를 보는 연산. empty 스택이 비어 있는지 아닌지를 알아보는 연산. size 스택에 저장되어있는 자료의 개수를 알아보는 연산.]]></content>
      <categories>
        <category>basics</category>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm_002]그대로 출력하기]]></title>
    <url>%2F2018%2F03%2F12%2Falgorithm%2F%5BAlgorithm_002%5D%EA%B7%B8%EB%8C%80%EB%A1%9C%20%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0%2F</url>
    <content type="text"><![CDATA[문제 입력 받은 대로 출력하는 프로그램을 작성하시오. 입력 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. 각 줄은 100글자를 넘지 않으며, 빈 줄이 주어질 수도 있고, 각 줄의 앞 뒤에 공백이 있을 수도 있다. 출력 입력받은 그대로 출력한다. 출처 백준온라인저지-11719번-그대로출력하기2(https://www.acmicpc.net/problem/11719) 풀이 방법1 - getchar() 이용123456789#include &lt;cstdio&gt; int main() &#123; char c; while ((c = getchar()) &amp;&amp; c != EOF) &#123; printf("%c",c); &#125; return 0;&#125; 방법2 - getline() 이용12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string str; while (getline(cin, str)) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125; 주의사항 scanf(&quot;%s&quot;,s);, cin &gt;&gt; s;은 빈칸으로 시작하거나 빈칸이 포함되는 온전한 한줄을 입력받지 못한다. fgets(s, 100, stdin);는 줄바꿈까지 입력받기 때문에, 주의한다. scanf(&quot;%[^\n]\n&quot;, s);는 줄바꿈을 입력받지 않기 때문에 좋지만, 각 줄의 앞 뒤에 있는 공백은 무시하고 입력을 받는다.즉, 빈줄을 받을 수 없고, 공백으로 시작하는 줄을 받을 수 없다.]]></content>
      <categories>
        <category>basics</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm_001]알고리즘 소개]]></title>
    <url>%2F2018%2F03%2F12%2Falgorithm%2F%5BAlgorithm_001%5D%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%86%8C%EA%B0%9C%2F</url>
    <content type="text"><![CDATA[알고리즘 소개 어떠한 문제를 해결하기위한 여러 동작들의 모임입니다. 시간복잡도(O) 개념 시간복잡도는 입력의 크기에 대해서 최악의 경우 시간이 얼마나 걸릴지 나타내는 방법입니다. 대표적인 시간 복잡도 시간복잡도 설명 Ο(1) 단순계산을 할 경우 ex) 배열에 접근하는 연산, a/b와 같은 연산. Ο(logN) N개를 절반으로 계속 나눌경우 Ο(N) 중복되지 않은 for문일 경우 O(NlogN) Ο(N^2) 2중 for문일 경우 Ο(N^3) 3중 for문일 경우 Ο(2^N) 크기가 N인 집합의 부분집합 Ο(N!) 크기가 N인 순열]]></content>
      <categories>
        <category>basics</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Hexo_03]테마설정]]></title>
    <url>%2F2018%2F03%2F12%2Fhexo%2F%5BHexo_03%5D%ED%85%8C%EB%A7%88%EC%84%A4%EC%A0%95%2F</url>
    <content type="text"><![CDATA[Hexo테마 설정 Hexo는 다양한 테마를 지원한다. 테마마다 설정방법이 조금씩 다르다. 공통적인 테마 설정 방법 테마마다 설정방법이 조금씩 다르지만, 기본적인 설정방법은 같다. github를 이용하여 테마를 다운받는다 12&gt; git clone &lt;hexo-theme의 github주소&gt; &lt;./themes/테마명&gt;&gt; git clone https://github.com/iissnan/hexo-theme-next.git ./themes/next 테마는 ./theme/ 경로에 위치한다. 테마는 아래의 구조를 가진다. . ├── _config.yml # 테마 설정 파일 ├── languages # 테마 언어폴더(ko.yml) ├── layout # 사이트를 어떻게 보여줄지 정의한 폴더(.ejs/.swing) ├── scripts # javascript모음 폴더 └── source # 실제 ./public 폴더에 위치할 파일 모음 마음에 드는 테마의 Docs를 꼭 확인해서 설정한다 블로그 글을 작성한 뒤, hexo d -g명령어를 사용하여 githube에 push한다. 사용자이름.github.io 주소로 접속해서 잘 배포되었는지 확인한다.(늦게 반영되는 경우도 있다.)]]></content>
      <categories>
        <category>git</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Hexo_02]마크다운(markdown)]]></title>
    <url>%2F2018%2F03%2F12%2Fhexo%2F%5BHexo_02%5D%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%2F</url>
    <content type="text"><![CDATA[마크다운(markdown) 소개 마크다운(markdown)은 일반 텍스트 문서의 양식을 편집하는 문법이다. 마크다운을 이용해 작성된 문서는 쉽게 HTML 등 다른 문서형태로 변환이 가능하다. 마크다운 작성법 제목 # 제목1 ## 제목2 ### 제목3 #### 제목4 ##### 제목5 ###### 제목6 큰 제목 ==================== 중간 제목 --------------------- 인용 > 인용1 >> 인용1-1 > 인용2 이탤릭체 *이탤릭체* _이탤릭체_ 볼드체 **볼드체** __볼드체__ 링크 [링크명](http://www.example.com) [링크명](http://www.example.com "사이트 제목") 순서있는 리스트 1. 첫 번째 2. 두 번째 3. 세 번째 순서없는 리스트 - 첫 번째 - 첫번째 -1 + 두 번째 * 세 번째 이미지 ![이미지명](이미지 경로)]]></content>
      <categories>
        <category>git</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Hexo_01]소개 및 시작하기]]></title>
    <url>%2F2018%2F03%2F11%2Fhexo%2F%5BHexo_01%5D%EC%86%8C%EA%B0%9C%20%EB%B0%8F%20%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0%2F</url>
    <content type="text"><![CDATA[Hexo 소개 Hexo는 빠르고 간단하고 강력한 블로그 프레임워크입니다. 기본적인 git, html, css, javaScript 지식이 필요합니다. Hexo 설치 전 준비하기 Hexo를 사용하기 위해 몇가지 준비사항이 있습니다. Node.js 설치 Node.js 로 접속힌다. Node.js LTS버전을 다운 받는다. 다운받은 Node.js LTS버전을 설치한다. crtl+r키를 누른 뒤 cmd를 실행시킵니다. 정상적인 설치확인을 위해 node버전과 npm버전을 확인합니다.12&gt; node -v&gt; npm -v github Repository 생성 github계정이 없다면, 가입합니다. github에서 New repository를 클릭합니다. Repository name에 사용자이름.github.io를 입력합니다. 다른 설정은 그대로 둔 뒤, Create repository를 클릭합니다. Hexo 설치본격적으로 Hexo를 설치합니다 crtl+r키를 누른 뒤 cmd를 실행시킵니다. Node.js를 실행시킵니다. 1&gt; node npm을 이용하여 hexo-cli를 설치합니다. 1&gt; npm install -g hexo-cli 적당한 위치에 원하는명(myblog)을 가진 폴더를 만듭니다. cd명령어를 이용하여, 만든폴더의 위치로 이동합니다. 12&gt; hexo init&gt; npm install 현재(root)디렉토리에 있는_config.yml이라는 설정파일을 이용해 블로그의 대부분 설정을 할 수 있습니다. 123456789101112131415title: #블로그의 제목subtitle: #블로그의 부제목description: #블로그의 설명author: #블로그의 소유자language: ko #블로그의 언어 설정 timezone: Asia/Seoul #블로그의 시간 설정url: https://사용자 이름.github.io #블로그의 주소theme: #블로그의 테마 false이면 테마를 끕니다.deploy: type: git repo: https://github.com/사용자이름/사용자이름.github.io.git branch: master 자세한 설정방법 : https://hexo.io/ko/docs/configuration.html 블로그 글 작성하기 hexo new [layout] &lt;title&gt;명령어를 이용하여 새 글 작성을 위한 파일 만들기. 1&gt; hexo new &quot;첫글&quot; /source/_posts/첫글.md 열어서 작성하기. 12345678910---title: &apos;첫글&apos; #글 제목 지정date: #시간 지정tags: #태그 지정categories: #카테고리 지정---# Hello World## Hello World### Hello World hexo g명령어를 사용하여, 정적 파일 생성. hexo s명령어를 사용하여, 로컬 서버 구동하기. 정상적으로 글 확인을 위해, 브라우저를 통해 접속.(기본:http://localhost:4000/) Hexo명령어 : https://hexo.io/ko/docs/commands.html]]></content>
      <categories>
        <category>git</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
